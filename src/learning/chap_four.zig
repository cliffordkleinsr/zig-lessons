const std = @import("std");

/// # 4 Debugging Zig applications
/// Being able to debug your applications is essential for any programmer who wants to do serious programming in any language.
/// That is why, in this chapter, we are going to talk about the available strategies and tools to debug applications written in Zig.
///
/// ## 4.1 Print debugging
/// We begin with the classic and battle-tested print debugging strategy.
/// The key advantage that debugging offers you is visibility.
/// With print statements you can easily see what results and objects are being produced by your application.
///
/// This is the essence of print debugging - using print expressions to see the values that are being generated by your program,
/// and, as a result, get a much better understanding of how your program is behaving.
///
/// Many programmers often resort to the print functions in Zig, such as the `stdout.print()`,
/// or, the `std.debug.print()`, to get a better understanding of their programs.
/// This is a known and old strategy that is very simple and effective, and it’s better known within the programming community as print debugging.
/// In Zig, you can print information to the stdout or stderr streams of your system.
///
/// Let’s begin with stdout.
/// For our purpose here, which is to write something to the stdout, especially to debug our program,
/// we use the `writer()` method, which gives you a writer object.
/// This writer object offers some helper methods to write stuff into the file descriptor object that represents the stdout stream specifically the `print()` method.
///
/// The `print()` method from this writer object is a “print formatter” type of a function.
/// In other words, this method works exactly like the `printf()` function from C, or, like `println!()` from Rust.
/// In the first argument of the function, you specify a template string, and, in the second argument,
/// you provide a list of values (or objects) that you want to insert into your template message.
///
/// Ideally, the template string in the first argument should contain some format specifier.
/// Each format specifier is matched to a value (or object) that you have listed in the second argument.
/// So, if you provided 5 different objects in the second argument, then, the template string should contain 5 format specifiers, one for each object provided.
///
/// Each format specifier is represented by a single letter, and you provide this format specifier inside a pair of curly braces.
/// So, if you want to format your object using the string specifier (s), then, you can insert the text {s} in your template string.
/// Here is a quick list of the most used format specifiers:
///
/// - `d`: for printing integers and floating-point numbers.
/// - `c`: for printing characters.
/// - `s`: for printing strings.
/// - `p`: for printing memory addresses.
/// - `x` & `X`: for printing hexadecimal values.
/// - `any`: use any compatible format specifier (i.e., it automatically selects a format specifier for you).
///
/// ## 4.2 Debugging through debuggers
/// Although print debugging is a valid and very useful strategy, most programmers prefer to use a debugger to debug their programs.
/// Since Zig is a low-level language, you can use either GDB (GNU Debugger), or LLDB (LLVM Project Debugger) as your debugger.
///
/// Both debuggers can work with Zig code, and it’s a matter of taste here. You choose the debugger of your preference, and you work with it.
/// In this book, I will use LLDB as my debugger in the examples.
///
/// ### 4.2.1 Compile your source code in debug mode (Linux & Mac Only)
/// In order to debug your program through a debugger, you must compile your source code in Debug mode.
/// Because when you compile your source code in other modes (such as Release),
/// the compiler usually strips out some essential information that is used by the debugger to read and track your program, like PDB (Program Database) files.
///
/// By compiling your source code in **Debug mode**, you ensure that the debugger will find the necessary information in your program to debug it.
/// By default, the compiler uses the **Debug mode** when compiling your code.
///
/// run
/// ```sh
///     zig build-exe ./src/learning/programs/add_program.zig
/// ```
///  when `0x2` is set on the switch
///
/// Now, we can start LLDB with add_program, like this:
/// ```sh
///     lldb add_program
/// ```
///
/// Having this in mind, when you compile your program with the build-exe command (which was described in Section 1.2.4),
/// if you don’t specify an explicit mode through the `-O` command-line 2 argument, then, the compiler will compile your code in **Debug mode**.
///
/// From now on, LLDB is started, and you can know that I’m executing LLDB commands by looking at the prefix `(lldb)`.
/// If something is prefixed with `(lldb)`, then you know that it’s a LLDB command.
///
/// The first thing I will do, is to set a breakpoint at the `main()` function, by executing `b chap_four.main`.
/// the debugger must be prefixed wwith the parent filename unless its the `main.zig` file.q
/// After that, I just start the execution of the program with `run`.
/// You can see in the output below, that the execution stopped at the first line in the function `main()`, as we expected.
///
/// Currently, we are in the first line at the `main()` function.
/// In this line, we create the n object, by executing the `add_and_increment()` function.
/// To execute the current line of code, and go to the next line, we can run the `n` LLDB command.
///
/// After we execute this line, we can also look at the value stored inside this n object by using the p LLDB command.
/// The syntax for this command is `p <name-of-object>`.
///
/// If we take a look at the value stored in the n object (p n), notice that it stores the hexadecimal value 0x06, which is the number 6 in decimal.
/// We can also see that this value has a type of unsigned char, which is an unsigned 8-bit integer.
/// We have talked already about this in Section 1.8, that u8 integers in Zig are equivalent to the C data type unsigned char.
///
/// Now, on the next line of code, we are executing the add_and_increment() function once again.
/// Why not step inside this function? Shall we? We can do that, by executing the s LLDB command.
/// Notice in the example below that, after executing this command, we have entered into the context of the `add_and_increment()` function.
///
/// Also notice in the example below that, I have walked two more lines in the function’s body, then,
/// I execute the `frame variable` LLDB command, to see at once, the value stored in each of the variables that were created inside the current scope.
///
/// ## 4.3 How to investigate the data type of your objects
/// Since Zig is a strongly-typed language, the data types associated with your objects are very important for your program.
/// So, debugging the data types associated with your objects might be important to understand bugs and errors in your program.
///
/// When you walk through your program with a debugger, you can inspect the types of your objects by simply printing them to the console, with the LLDB p command.
/// But you also have alternatives embedded in the language itself to access the data types of your objects.
///
/// In Zig, you can retrieve the data type of an object, by using the built-in function @TypeOf().
/// Just apply this function over the object, and you get access to the data type of the object.
///
/// This function is similar to the `type()` built-in function from Python, or, the `typeof` operator in Javascript.
pub fn main() !void {
    switch (@as(u8, 0x2)) {
        0x1 => try printer(),
        0x2 => try helpers(),
        else => unreachable,
    }
}

fn add(x: u16, y: u16) u16 {
    return x + y;
}

fn printer() !void {
    // stdout
    var stdout_buffer: [0x30]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout = &stdout_writer.interface;

    try stdout.print("109 + 333 = {d}\n", .{add(109, 250)});
    try stdout.flush();
}

fn helpers() !void {
    var stdout_buffer: [0x30]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout = &stdout_writer.interface;

    const number: i32 = 5;
    std.debug.assert(@TypeOf(number) == i32);
    try std.testing.expect(@TypeOf(number) == i32); //or
    try stdout.print("{any}\n", .{@TypeOf(number)});
    try stdout.flush();
}
