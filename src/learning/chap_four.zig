const std = @import("std");

/// # 4 Debugging Zig applications
/// Being able to debug your applications is essential for any programmer who wants to do serious programming in any language.
/// That is why, in this chapter, we are going to talk about the available strategies and tools to debug applications written in Zig.
///
/// ## 4.1 Print debugging
/// We begin with the classic and battle-tested print debugging strategy.
/// The key advantage that debugging offers you is visibility.
/// With print statements you can easily see what results and objects are being produced by your application.
///
/// This is the essence of print debugging - using print expressions to see the values that are being generated by your program,
/// and, as a result, get a much better understanding of how your program is behaving.
///
/// Many programmers often resort to the print functions in Zig, such as the `stdout.print()`,
/// or, the `std.debug.print()`, to get a better understanding of their programs.
/// This is a known and old strategy that is very simple and effective, and it’s better known within the programming community as print debugging.
/// In Zig, you can print information to the stdout or stderr streams of your system.
///
/// Let’s begin with stdout.
/// For our purpose here, which is to write something to the stdout, especially to debug our program,
/// we use the `writer()` method, which gives you a writer object.
/// This writer object offers some helper methods to write stuff into the file descriptor object that represents the stdout stream specifically the `print()` method.
pub fn main() !void {
    switch (@as(u8, 0x1)) {
        0x1 => 0,
        else => unreachable,
    }
}
